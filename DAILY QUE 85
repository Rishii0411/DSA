2025-12-11|Maximum Profit with Hierarchy Discounts and Budget Constraint

Question
You are given present[], future[], hierarchy[][], and a budget.  
Return the maximum profit achievable under the hierarchy discount rules and budget constraint.

Approach
1.	Model the company hierarchy as a tree rooted at employee 1.
2.	This is a **tree knapsack DP** problem with two states per node:
	-	Case 0: the boss of this employee did NOT buy stock → no discount available.
	-	Case 1: the boss DID buy stock → discount available for this employee.
3.	Define DP for each node u:
	-	dp0[u][b]: maximum profit from subtree of u using budget b when u has no discount.
	-	dp1[u][b]: maximum profit from subtree of u using budget b when u has discount.
4.	Transitions at node u:
	-	Option A: do NOT buy u’s stock  
		-	children are processed with dp0 (no discount passed).
	-	Option B: buy u’s stock  
		-	cost is present[u] (or present[u]/2 if discounted),
		-	profit gained = future[u] − cost,
		-	children are processed with dp1 (discount passed).
5.	Merge children one by one using knapsack convolution (budget DP).
6.	The root (employee 1) never gets a discount from above, so we start with dp0[root].
7.	The answer is the maximum value in dp0[root][b] for b ≤ budget.
8.	Time complexity: O(n × budget²) in worst case (tree knapsack).  
   Space complexity: O(n × budget).

Solution
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

class Solution {
public:
    int n, B;
    vector<int> present, future;
    vector<vector<int>> tree;

    pair<vector<ll>, vector<ll>> dfs(int u) {
        vector<ll> dp0(B + 1, LLONG_MIN);
        vector<ll> dp1(B + 1, LLONG_MIN);

        dp0[0] = 0;
        dp1[0] = 0;

        for (int v : tree[u]) {
            auto child = dfs(v);
            vector<ll> ndp0(B + 1, LLONG_MIN);
            vector<ll> ndp1(B + 1, LLONG_MIN);

            for (int b = 0; b <= B; b++) {
                if (dp0[b] < 0 && dp1[b] < 0) continue;
                for (int cb = 0; cb + b <= B; cb++) {
                    if (child.first[cb] >= 0) {
                        ndp0[b + cb] = max(ndp0[b + cb],
                                           dp0[b] + child.first[cb]);
                    }
                    if (child.second[cb] >= 0) {
                        ndp1[b + cb] = max(ndp1[b + cb],
                                           dp1[b] + child.second[cb]);
                    }
                }
            }
            dp0 = ndp0;
            dp1 = ndp1;
        }

        // Option: buy stock of u
        int cost0 = present[u];
        int cost1 = present[u] / 2;
        ll profit0 = future[u] - cost0;
        ll profit1 = future[u] - cost1;

        for (int b = B; b >= 0; b--) {
            if (b >= cost0 && dp0[b - cost0] >= 0) {
                dp0[b] = max(dp0[b],
                             dp0[b - cost0] + profit0);
            }
            if (b >= cost1 && dp1[b - cost1] >= 0) {
                dp1[b] = max(dp1[b],
                             dp1[b - cost1] + profit1);
            }
        }

        return {dp0, dp1};
    }

    ll maxProfit(int n_,
                 vector<int>& present_,
                 vector<int>& future_,
                 vector<vector<int>>& hierarchy,
                 int budget) {

        n = n_;
        B = budget;
        present = present_;
        future = future_;
        tree.assign(n, {});

        for (auto &e : hierarchy) {
            int u = e[0] - 1;
            int v = e[1] - 1;
            tree[u].push_back(v);
        }

        auto res = dfs(0);
        ll ans = 0;
        for (int b = 0; b <= B; b++) {
            ans = max(ans, res.first[b]);
        }
        return ans;
    }
};
