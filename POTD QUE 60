2025-11-03 | Find Eventual Safe States

Problem Statement
Given a directed graph with V vertices numbered from 0 to V-1 and E directed edges, represented as a 2D array edges[][], where each element edges[i] = [u, v] represents a directed edge from vertex u → v, return all safe nodes of the graph.

Definitions:
	•	A terminal node is a vertex with no outgoing edges.
	•	A safe node is one from which every possible path eventually reaches a terminal node (no cycles are involved).

If a vertex is part of or leads to a cycle, it is considered unsafe.

Constraints:
•	1 ≤ V ≤ 10⁴
•	0 ≤ E ≤ 10⁴
•	Graph may be disconnected.

Approach / Explanation
	1.	Observation
•	A node is safe if all paths from it lead to terminal nodes.
•	If a node leads to a cycle, it’s unsafe.
•	We can use DFS with state marking to detect cycles and classify nodes.
	2.	State Tracking
•	vis[node] == -1: unvisited
•	vis[node] == 1: visiting (currently in recursion stack)
•	vis[node] == 2: safe
	3.	Algorithm
•	Build the adjacency list.
•	Use DFS to traverse nodes:
	•	If a node’s DFS path revisits a node marked as 1, a cycle exists → unsafe.
	•	If all children of a node are safe, mark it as safe (2).
•	Collect all nodes marked as safe.
	4.	Time Complexity
•	O(V + E), since each edge and node is processed once.

SOLUTION:
class Solution {
public:
    void createadj(vector<vector<int>> &edges, vector<vector<int>> &adj) {
        for (auto &it : edges) {
            adj[it[0]].push_back(it[1]);
        }
    }

    bool check(vector<vector<int>> &adj, int node, vector<int> &vis) {
        // vis[node] == -1 → unvisited
        // vis[node] == 1  → visiting (part of current recursion stack)
        // vis[node] == 2  → safe

        if (vis[node] == 1) return false;  // cycle found
        if (vis[node] == 2) return true;   // already known safe

        vis[node] = 1; // mark as visiting
        for (int next : adj[node]) {
            if (!check(adj, next, vis)) {
                return false; // child leads to cycle → unsafe
            }
        }

        vis[node] = 2; // mark as safe after checking all children
        return true;
    }

    vector<int> safeNodes(int V, vector<vector<int>> &edges) {
        vector<vector<int>> adj(V);
        createadj(edges, adj);

        vector<int> vis(V, -1);
        vector<int> ans;

        for (int i = 0; i < V; i++) {
            if (check(adj, i, vis)) {
                ans.push_back(i);
            }
        }

        return ans;
    }
};
