2026-02-09|Convert BST to Balanced BST

	Question
Given the root of a binary search tree,  
return a balanced binary search tree containing the same values.

	Approach
1.	Key insight:
	-	Inorder traversal of a BST gives elements in **sorted order**.
2.	Strategy:
	1.	Perform an **inorder traversal** of the given BST.
		-	Store all node values in a vector.
	2.	Now build a balanced BST from this **sorted array**.
3.	How to build a balanced BST from a sorted array:
	-	Choose the middle element as the root.
	-	Recursively build:
		-	Left subtree from the left half.
		-	Right subtree from the right half.
4.	This guarantees:
	-	The BST property is preserved.
	-	The height difference at every node is at most 1.
5.	Time Complexity:
	-	Inorder traversal: O(n)
	-	Rebuilding BST: O(n)
6.	Space Complexity:
	-	O(n) for storing node values
	-	O(log n) recursion stack for building the tree

	Solution

class Solution {
public:
    void inorder(TreeNode* root, vector<int>& vals) {
        if (!root) return;
        inorder(root->left, vals);
        vals.push_back(root->val);
        inorder(root->right, vals);
    }

    TreeNode* buildBalancedBST(vector<int>& vals, int l, int r) {
        if (l > r) return nullptr;

        int mid = l + (r - l) / 2;
        TreeNode* root = new TreeNode(vals[mid]);

        root->left = buildBalancedBST(vals, l, mid - 1);
        root->right = buildBalancedBST(vals, mid + 1, r);

        return root;
    }

    TreeNode* balanceBST(TreeNode* root) {
        vector<int> vals;
        inorder(root, vals);
        return buildBalancedBST(vals, 0, vals.size() - 1);
    }
};

	Key Insight
A BST can always be balanced by:
1.	Extracting its sorted order via inorder traversal.
2.	Rebuilding it using a divide-and-conquer strategy.
This transforms even a completely skewed BST into a height-balanced one in linear time.
