2025-12-12 | Smallest Subtree Containing All the Deepest Nodes

	Question
Given the root of a binary tree,  
return the smallest subtree that contains all the deepest nodes.

	Approach
1.	Use a **postorder DFS** traversal.
2.	For each node, compute:
	-	The maximum depth of its left subtree.
	-	The maximum depth of its right subtree.
3.	Decision logic:
	-	If leftDepth == rightDepth:
		-	The deepest nodes lie in **both subtrees**.
		-	So, the current node is the root of the smallest subtree.
	-	If leftDepth > rightDepth:
		-	The deepest nodes lie only in the left subtree.
	-	If rightDepth > leftDepth:
		-	The deepest nodes lie only in the right subtree.
4.	Return both:
	-	The subtree root that contains all deepest nodes.
	-	The depth of the subtree.
5.	This approach naturally finds the **lowest common ancestor of all deepest leaves**.
6.	Time Complexity: O(n), where n is the number of nodes.  
   Space Complexity: O(h), where h is the height of the tree (recursion stack).

	Solution

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    pair<TreeNode*, int> dfs(TreeNode* root) {
        if (!root)
            return {NULL, 0};

        auto left = dfs(root->left);
        auto right = dfs(root->right);

        if (left.second == right.second) {
            // Both sides have deepest nodes
            return {root, left.second + 1};
        } 
        else if (left.second > right.second) {
            // Deepest nodes are in left subtree
            return {left.first, left.second + 1};
        } 
        else {
            // Deepest nodes are in right subtree
            return {right.first, right.second + 1};
        }
    }

    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        return dfs(root).first;
    }
};
