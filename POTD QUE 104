2025-12-11|Merge Overlapping Intervals

Question
Given an array of intervals arr[][], where arr[i] = [starti, endi], merge all overlapping intervals and return the resulting list.

Approach
1.	First, sort all intervals based on their start time.
2.	Initialize an empty result list.
3.	Traverse the sorted intervals one by one:
	-	If the result list is empty or the current interval does not overlap with the last interval in the result, add it directly.
	-	If it overlaps (current.start â‰¤ last.end), merge them by updating last.end = max(last.end, current.end).
4.	After processing all intervals, the result list will contain merged, non-overlapping intervals.
5.	Time complexity: O(n log n) due to sorting.  
   Space complexity: O(n) for the output list.

Solution
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};

        // Sort intervals by starting time
        sort(intervals.begin(), intervals.end(),
             [](const vector<int>& a, const vector<int>& b) {
                 return a[0] < b[0];
             });

        vector<vector<int>> merged;
        merged.push_back(intervals[0]);

        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] <= merged.back()[1]) {
                // Overlapping intervals, merge them
                merged.back()[1] = max(merged.back()[1], intervals[i][1]);
            } else {
                // No overlap
                merged.push_back(intervals[i]);
            }
        }

        return merged;
    }
};
