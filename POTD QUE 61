2025-11-04 | Minimum Cost to Reach the Last Stair

Problem Statement
You are given an integer array height[] where height[i] represents the height of the i-th stair.
A frog starts at the first stair (index 0) and wants to reach the last stair (index n-1).
	•	From stair i, it can jump to i + 1 or i + 2 (if possible).
	•	The cost of each jump is abs(height[i] - height[j]), where j is the stair the frog jumps to.

Return the minimum total cost required for the frog to reach the last stair.

Approach / Explanation
	1.	Observation
•	This problem can be solved efficiently using Dynamic Programming.
•	The frog has two choices at each stair:
	•	Jump to i + 1 with cost abs(height[i] - height[i+1]) + dp[i+1]
	•	Jump to i + 2 with cost abs(height[i] - height[i+2]) + dp[i+2]
•	We take the minimum of these two choices.
	2.	Recursive Relation
Let dp[i] represent the minimum cost to reach the last stair starting from stair i.

dp[i] = \min( |height[i] - height[i+1]| + dp[i+1],\ |height[i] - height[i+2]| + dp[i+2] )

Base cases:
	•	dp[n-1] = 0 (already on the last stair)
	•	dp[n-2] = |height[n-1] - height[n-2]|

	3.	Iterative (Bottom-Up) Approach
•	We fill the dp array starting from the end (last stair) moving backward.
•	Finally, dp[0] gives the minimum total cost.
	4.	Time and Space Complexity
•	Time Complexity: O(n)
•	Space Complexity: O(n) (can be optimized to O(1) using two variables).

SOLUTION:
class Solution {
  public:
    int minCost(vector<int>& height) {
        int n = height.size();
        if (n == 1) return 0;
        if (n == 2) return abs(height[1] - height[0]);

        vector<int> dp(n, 0);
        dp[n - 1] = 0;
        dp[n - 2] = abs(height[n - 1] - height[n - 2]);

        for (int i = n - 3; i >= 0; i--) {
            int oneJump = abs(height[i] - height[i + 1]) + dp[i + 1];
            int twoJump = abs(height[i] - height[i + 2]) + dp[i + 2];
             dp[i] = min(oneJump, twoJump);
        }

        return dp[0];
    }
};
