2025-11-06 | Wildcard Pattern Matching

Problem Statement
Given two strings pat and txt, return true if the pattern matches the text completely; otherwise, return false.
Rules:
	•	'?' matches any single character.
	•	'*' matches any sequence of characters (even empty).
	•	Matching must cover the entire text.

Example
Input:
pat = "a*b?d"
txt = "abxcd"

Output:
true
Explanation:
	•	a* matches abx,
	•	b?d matches bcd.
Full match achieved.

⚙️ Approach / Explanation
We’ll use Dynamic Programming (DP) to efficiently check pattern matches.

1. Define DP State
Let dp[i][j] be true if the first i characters of the pattern pat[0..i-1] match the first j characters of the text txt[0..j-1].


2. Base Cases
	•	dp[0][0] = true → Empty pattern matches empty text.
	•	dp[i][0] = true only if all characters in pat[0..i-1] are '*' (since * can match empty).
	•	dp[0][j] = false → Empty pattern cannot match non-empty text.


3. Transition Rules
For each i (pattern index) and j (text index):

Pattern Character	Condition	DP Transition
Normal character (like a–z)	If pat[i-1] == txt[j-1]	dp[i][j] = dp[i-1][j-1]
'?'	Matches any single character	dp[i][j] = dp[i-1][j-1]
'*'	Can match empty or multiple chars	dp[i][j] = dp[i-1][j] (empty) OR dp[i][j-1] (one or more chars)


4. Final Answer
The result will be dp[n][m], where:
	•	n = length of pat
	•	m = length of txt

Time & Space Complexity
Metric	Value
Time Complexity	O(n × m)
Space Complexity	O(n × m)
Optimized Space (optional)	O(m) using rolling arrays

SOLUTION:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool match(string pat, string txt) {
        int n = pat.size();
        int m = txt.size();

        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));

        // Base case: empty pattern and empty text
        dp[0][0] = true;

        // Handle patterns like "*", "**", etc. that can match empty string
        for (int i = 1; i <= n; i++) {
            if (pat[i - 1] == '*')
                dp[i][0] = dp[i - 1][0];
        }

        // Fill DP table
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (pat[i - 1] == txt[j - 1] || pat[i - 1] == '?') {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else if (pat[i - 1] == '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                }
                else {
                    dp[i][j] = false;
                }
            }
        }

        return dp[n][m];
    }
};
