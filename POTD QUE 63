2025-11-06 | Weighted Job Scheduling (Maximum Profit with Non-Overlapping Jobs)

Problem Statement
You are given a 2D array jobs[][] of size n × 3, where each row represents a job:
	•	jobs[i][0]: Start time of the job
	•	jobs[i][1]: End time of the job
	•	jobs[i][2]: Profit from completing the job
Find the maximum profit that can be obtained by scheduling a set of non-overlapping jobs.

Note:
If a job ends at time X, another job can start exactly at time X (they are considered non-overlapping).


Approach / Explanation
1. Observation
This is a Weighted Interval Scheduling problem — a classic dynamic programming challenge.

For each job, you can either:
	•	Include it: take its profit plus the best profit achievable before it starts.
	•	Exclude it: skip it and consider the next job.

We need to find the maximum of these choices for all jobs.

2. Steps
Step 1: Sort jobs by end time
This allows us to easily determine which earlier jobs don’t overlap.

Step 2: Binary Search for Compatibility
For each job i, find the last job j that ends before or at the start of job i.
We can find this efficiently using binary search over the sorted jobs.

Step 3: Dynamic Programming
Let dp[i] = maximum profit considering the first i jobs (1-indexed).

Recurrence:
dp[i] = \max(dp[i-1], jobs[i-1][2] + dp[index])
where index is the position of the last non-overlapping job (found via binary search).

Base Case:
dp[0] = 0 (no jobs → no profit).

3. Complexity
	•	Sorting: O(n log n)
	•	For each job, binary search: O(log n)
Total: O(n log n)
	•	Space Complexity: O(n)

SOLUTION:

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    static bool compare(vector<int>& a, vector<int>& b) {
        return a[1] < b[1]; // sort by end time
    }

    int jobScheduling(vector<vector<int>>& jobs) {
        int n = jobs.size();
        sort(jobs.begin(), jobs.end(), compare);

        vector<int> endTimes;
        for (auto &job : jobs) endTimes.push_back(job[1]);

        vector<int> dp(n + 1, 0); // dp[i] = max profit till i jobs

        for (int i = 1; i <= n; i++) {
            int profit = jobs[i - 1][2];
            int start = jobs[i - 1][0];

            // find last job that ends before this job starts
            int idx = upper_bound(endTimes.begin(), endTimes.end(), start) - endTimes.begin() - 1;

            // include or exclude
            profit += dp[idx + 1];
            dp[i] = max(dp[i - 1], profit);
        }

        return dp[n];
    }
};
