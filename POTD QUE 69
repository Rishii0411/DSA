2025-11-06 | Interleaving String Check

Problem Statement

Given strings s1, s2, and s3, determine whether s3 is formed by an interleaving of s1 and s2.

Interleaving means that s3 is created by merging characters from s1 and s2 while preserving the relative order of characters from each string.  
Conditions:
• Characters from s1 must appear in s3 in the same order as in s1.  
• Characters from s2 must appear in s3 in the same order as in s2.  
• Length of s3 must be equal to |s1| + |s2|.

Return true if s3 is a valid interleaving of s1 and s2, otherwise return false.


Approach / Explanation

1. Observation  
If the length of s3 is not exactly the sum of lengths of s1 and s2, it can never be an interleaving.  
Therefore, immediate rejection is possible.

2. Dynamic Programming  
We use a 2D DP table dp[i][j] meaning:  
dp[i][j] = true if s1[0..i-1] and s2[0..j-1] can interleave to form s3[0..i+j-1].

Transitions:  
• If s1[i-1] == s3[i+j-1] and dp[i-1][j] is true → dp[i][j] = true  
• If s2[j-1] == s3[i+j-1] and dp[i][j-1] is true → dp[i][j] = true  

3. Base Cases  
• dp[0][0] = true  
• First row: only s2 contributing  
• First column: only s1 contributing  

4. Time Complexity  
• Time Complexity: O(n * m)  
• Space Complexity: O(n * m)  
where n = s1.length(), m = s2.length().

SOLUTION:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n = s1.size(), m = s2.size();
        if (n + m != s3.size()) return false;

        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));
        dp[0][0] = true;

        // First column (using only s1)
        for (int i = 1; i <= n; i++)
            dp[i][0] = dp[i-1][0] && s1[i-1] == s3[i-1];

        // First row (using only s2)
        for (int j = 1; j <= m; j++)
            dp[0][j] = dp[0][j-1] && s2[j-1] == s3[j-1];

        // Fill DP table
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                bool fromS1 = s1[i-1] == s3[i+j-1] && dp[i-1][j];
                bool fromS2 = s2[j-1] == s3[i+j-1] && dp[i][j-1];
                dp[i][j] = fromS1 || fromS2;
            }
        }

        return dp[n][m];
    }
};
