2025-09-28 | Maximum k for Two Adjacent Strictly Increasing Subarrays
3350. Adjacent Increasing Subarrays Detection II

Approach
	1.	Compute Length of Increasing Subarrays:
	•	Create an array inc[] where inc[i] stores the length of the strictly increasing subarray starting at index i.
	•	Iterate from the end to the beginning of nums to fill inc[].
	2.	Check Adjacent Subarrays:
	•	For each index i, calculate j = i + inc[i].
	•	If j < n, the subarray starting at i and the next starting at j can form two adjacent increasing subarrays.
	•	Update the maximum k as min(inc[i], inc[j]).
	3.	Handle Consecutive Runs:
	•	To ensure correctness, also track consecutive increasing runs using a separate run counter.
	•	Update the maximum k as max(ans, run / 2) to account for any overlapping sequences.
	4.	Return the Maximum k:
	•	After iterating through the array, the variable ans contains the maximum possible value of k.

SOLUTION:
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) return 0;

        vector<int> inc(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) inc[i] = inc[i + 1] + 1;
        }

        int ans = 1;

        for (int i = 0; i < n; i++) {
            int j = i + inc[i];
            if (j < n) {
                int k = min(inc[i], inc[j]);
                ans = max(ans, k);
            }
        }

        int run = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) run++;
            else run = 1;
            ans = max(ans, run / 2);
        }

        return ans;
    }
};
