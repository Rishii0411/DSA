2025-12-12 | Shortest Path with One-Time Edge Reversal Switch per Node

	Question
Given a directed weighted graph with one-time reversible edges per node,  
find the minimum cost path from node `0` to node `n-1`.

	Approach
1.	This is a **shortest path problem with state**.
2.	The key complexity:
	-	Whether the switch of a node has been used or not changes future options.
3.	State definition:
	-	`(node, used)` where:
		-	`node` = current node
		-	`used` = whether this node’s switch has already been used (0 or 1)
4.	Graph construction:
	-	Store original edges normally.
	-	Also store **reverse adjacency** so we know which edges can be reversed at a node.
5.	Dijkstra’s algorithm with extended state:
	-	Distance array: `dist[node][used]`
6.	Transitions:
	1.	Normal move:
		-	From `u` to `v` using original edge `u → v` with cost `w`
		-	Switch usage state remains the same
	2.	Reverse-edge move (only if `used == 0`):
		-	From `u` to `v` by reversing `v → u`
		-	Cost = `2 × w`
		-	New state becomes `(v, 1)` (switch used)
7.	Run Dijkstra until all reachable states are processed.
8.	The answer is:
		min(dist[n-1][0], dist[n-1][1])
9.	If both are unreachable, return `-1`.
10.	Time Complexity:
	-	O((n + m) log (n))
11.	Space Complexity:
	-	O(n + m)

	Solution

class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges) {
        vector<vector<pair<int,int>>> adj(n), radj(n);

        // Build adjacency and reverse adjacency
        for (auto &e : edges) {
            int u = e[0], v = e[1], w = e[2];
            adj[u].push_back({v, w});
            radj[v].push_back({u, w});
        }

        const long long INF = 1e18;
        vector<vector<long long>> dist(n, vector<long long>(2, INF));

        // Min-heap: {cost, node, usedSwitch}
        priority_queue<array<long long,3>,
            vector<array<long long,3>>,
            greater<array<long long,3>>> pq;

        dist[0][0] = 0;
        pq.push({0, 0, 0});

        while (!pq.empty()) {
            auto [cost, u, used] = pq.top();
            pq.pop();

            if (cost > dist[u][used]) continue;

            // Normal edges
            for (auto &[v, w] : adj[u]) {
                if (dist[v][used] > cost + w) {
                    dist[v][used] = cost + w;
                    pq.push({dist[v][used], v, used});
                }
            }

            // Reverse edges using switch (only once per node)
            if (used == 0) {
                for (auto &[v, w] : radj[u]) {
                    if (dist[v][1] > cost + 2LL * w) {
                        dist[v][1] = cost + 2LL * w;
                        pq.push({dist[v][1], v, 1});
                    }
                }
            }
        }

        long long ans = min(dist[n-1][0], dist[n-1][1]);
        return ans == INF ? -1 : (int)ans;
    }
};
