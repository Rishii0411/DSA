2025-09-20 | Minimum Cost to Cut a Board into Squares

QUESTION:
Given a board of dimensions n × m that needs to be cut into n*m squares. The cost of making a cut along a horizontal or vertical edge is provided in two arrays:
	•	x[]: Cutting costs along the vertical edges (length-wise).
	•	y[]: Cutting costs along the horizontal edges (width-wise).

Find the minimum total cost required to cut the board into squares optimally.

⸻

APPROACH:
The idea is to use a greedy strategy:
	1.	Sort both cost arrays in descending order, since we want to use the expensive cuts earlier when fewer pieces are present.
	2.	Maintain counters for the number of horizontal pieces (hPieces) and vertical pieces (vPieces). Initially, both are 1.
	3.	At each step:
	•	Compare the current largest remaining cut cost from horizontal and vertical.
	•	If the horizontal cut is costlier, apply it first and multiply the cost by the current number of vertical pieces.
	•	Otherwise, apply the vertical cut and multiply the cost by the current number of horizontal pieces.
	4.	Continue until all cuts are applied.
	5.	This ensures high-cost cuts are distributed over fewer pieces, keeping the total cost minimal.

The time complexity is O(n log n + m log m) due to sorting, followed by a linear greedy merge.

SOLUTION:
class Solution {
public:
    int minCost(int n, int m, vector<int>& horizontal, vector<int>& vertical) {
        // Sort cutting costs (largest first for greedy choice)
        sort(horizontal.rbegin(), horizontal.rend());
        sort(vertical.rbegin(), vertical.rend());

        int hPieces = 1, vPieces = 1;
        int hIndex = 0, vIndex = 0;
        int cost = 0;

        // Greedy choice: always take the larger cut first
        while (hIndex < horizontal.size() && vIndex < vertical.size()) {
            if (horizontal[hIndex] >= vertical[vIndex]) {
                cost += horizontal[hIndex] * vPieces;
                hPieces++;
                hIndex++;
            } else {
                cost += vertical[vIndex] * hPieces;
                vPieces++;
                vIndex++;
            }
        }

        // Add remaining horizontal cuts
        while (hIndex < horizontal.size()) {
            cost += horizontal[hIndex] * vPieces;
            hPieces++;
            hIndex++;
        }

        // Add remaining vertical cuts
        while (vIndex < vertical.size()) {
            cost += vertical[vIndex] * hPieces;
            vPieces++;
            vIndex++;
        }

        return cost;
    }
};
