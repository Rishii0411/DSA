2025-12-08 | Count Special Triplets (i, j, k) with nums[i] = 2·nums[j] and nums[k] = 2·nums[j]

Question
You are given an integer array nums.  
A special triplet is defined as indices (i, j, k) such that:
0 ≤ i < j < k < n,
nums[i] == 2 * nums[j],
nums[k] == 2 * nums[j].  
Return the total count modulo 1e9+7.

Approach
1.  Preprocessing idea:
    - For each j, we need:
      leftCount = number of i < j with nums[i] = 2 * nums[j].
      rightCount = number of k > j with nums[k] = 2 * nums[j].
2.  Build prefix counts:
    - Traverse from left to right, maintain a hash map freqLeft.
      For current j, leftCount = freqLeft[2 * nums[j]].
      Then increment freqLeft[nums[j]].
3.  Build suffix counts:
    - Traverse from right to left, maintain hash map freqRight.
      For current j, rightCount = freqRight[2 * nums[j]].
      Then increment freqRight[nums[j]].
4.  For each j, total triplets contributed is:
      (leftCount[j] * rightCount[j]) % MOD.
5.  Add them all modulo MOD.
6.  Complexity: O(n) expected with hash maps.

Solution

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 1000000007;

class Solution {
public:
    long long countSpecialTriplets(vector<long long>& nums) {
        int n = nums.size();
        vector<ll> leftCnt(n, 0), rightCnt(n, 0);

        unordered_map<ll, ll> freqLeft, freqRight;

        for (int j = 0; j < n; j++) {
            long long need = 2LL * nums[j];
            if (freqLeft.count(need)) leftCnt[j] = freqLeft[need];
            freqLeft[nums[j]]++;
        }

        for (int j = n - 1; j >= 0; j--) {
            long long need = 2LL * nums[j];
            if (freqRight.count(need)) rightCnt[j] = freqRight[need];
            freqRight[nums[j]]++;
        }

        long long ans = 0;
        for (int j = 0; j < n; j++) {
            ans = (ans + (leftCnt[j] * rightCnt[j]) % MOD) % MOD;
        }

        return ans;
    }
};
