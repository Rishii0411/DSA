2025-12-12 | Implement k Queues in a Single Array

	Question
Implement a class `kQueues` that supports:
1.	enqueue(x, i) → insert element x into the i-th queue  
2.	dequeue(i) → remove and return front element of the i-th queue, or -1 if empty  
3.	isEmpty(i) → check if the i-th queue is empty  
4.	isFull() → check if the shared array is completely full  

	Approach
1.	This is a classic **k queues in a single array** problem using:
	-	One array `arr[]` to store values
	-	One array `next[]` to manage links
	-	Arrays `front[]` and `rear[]` for each queue
2.	Use a **free list**:
	-	`freeSpot` points to the first free index in the array
3.	Data Structures:
	-	arr[n] → stores elements
	-	next[n] → links elements inside queues and free list
	-	front[k], rear[k] → track queues
4.	Initialization:
	-	All queues are empty → front[i] = rear[i] = -1
	-	next[i] = i+1 to form free list
	-	freeSpot = 0
5.	Enqueue:
	-	If freeSpot == -1 → array is full
	-	Take index = freeSpot
	-	Update freeSpot = next[index]
	-	Insert element and link it to queue i
6.	Dequeue:
	-	If front[i] == -1 → queue empty
	-	Remove front element
	-	Add freed index back to free list
7.	Time Complexity:
	-	All operations are O(1)
8.	Space Complexity:
	-	O(n + k)

	Solution

class kQueues {
    int n, k;
    vector<int> arr, next, front, rear;
    int freeSpot;

public:
    kQueues(int n, int k) {
        this->n = n;
        this->k = k;

        arr.resize(n);
        next.resize(n);
        front.resize(k, -1);
        rear.resize(k, -1);

        // Initialize free list
        for (int i = 0; i < n - 1; i++) {
            next[i] = i + 1;
        }
        next[n - 1] = -1;
        freeSpot = 0;
    }

    void enqueue(int x, int i) {
        if (isFull()) return;

        int index = freeSpot;
        freeSpot = next[index];

        if (front[i] == -1) {
            front[i] = index;
        } else {
            next[rear[i]] = index;
        }

        next[index] = -1;
        rear[i] = index;
        arr[index] = x;
    }

    int dequeue(int i) {
        if (isEmpty(i)) return -1;

        int index = front[i];
        front[i] = next[index];

        if (front[i] == -1)
            rear[i] = -1;

        next[index] = freeSpot;
        freeSpot = index;

        return arr[index];
    }

    bool isEmpty(int i) {
        return front[i] == -1;
    }

    bool isFull() {
        return freeSpot == -1;
    }
};
