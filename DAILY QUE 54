2025-11-06 | Count Substrings With Dominant Ones

Problem Statement  

You are given a binary string s.

A substring has dominant ones if:
count_ones ≥ (count_zeros)²

Return the total number of such substrings.

Approach / Explanation  

1. Observation  
For each substring defined by indices [i, j], we need counts of ones and zeros.  
A naive triple-nested loop would be too slow.  
However, using prefix sums allows computing counts for any substring in O(1) time.

2. Brute Force with Prefix Sums  
Let pref1[i] = number of ones in s[0..i-1]  
Let pref0[i] = number of zeros in s[0..i-1]

Then for any substring s[l..r]:

ones = pref1[r+1] − pref1[l]  
zeros = pref0[r+1] − pref0[l]

Check if ones ≥ zeros².

3. Complexity Justification  
The condition ones ≥ zeros² grows rapidly with zeros.  
When zeros ≥ √n, zeros² is large, so satisfying the condition becomes difficult.  
Thus, most valid substrings contain very few zeros, keeping runtime manageable even with O(n²) checking.

4. Time Complexity  
• Time Complexity: O(n²)  
• Space Complexity: O(n)  
This is acceptable for typical constraints (n up to ~5000).  
For extremely large n, further optimization would be needed, but the O(n²) prefix-sum solution is the standard approach.

SOLUTION:
class Solution {
 public:
  int numberOfSubstrings(string s) {
    int ans = 0;

    // Iterate through all possible number of 0s.
    for (int zero = 0; zero + zero * zero <= s.length(); ++zero) {
      int lastInvalidPos = -1;
      vector<int> count(2);
      for (int l = 0, r = 0; r < s.length(); ++r) {
        ++count[s[r] - '0'];
        // Try to shrink the window to maintain the "minimum" length of the
        // valid substring.
        for (; l < r; ++l)
          if (s[l] == '0' && count[0] > zero) {
            --count[0];  // Remove an extra '0'.
            lastInvalidPos = l;
          } else if (s[l] == '1' && count[1] - 1 >= zero * zero) {
            --count[1];  // Remove an extra '1'.
          } else {
            break;  // Cannot remove more characters.
          }
        if (count[0] == zero && count[1] >= zero * zero)
          // Add valid substrings ending in s[r] to the answer. They are
          // s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].
          ans += l - lastInvalidPos;
      }
    }

    return ans;
  }
};
