2025-11-06 | Count Distinct Substrings in a String

Problem Statement  
Given a lowercase string `s`, return the number of **distinct non-empty substrings** of `s`.

Approach / Explanation  
To solve this efficiently, we use a **Suffix Automaton (SAM)**.
1. What does a Suffix Automaton do?
A SAM compactly represents all substrings of a string.  
Each state in the SAM represents a set of end positions of substrings.

2. Key Property  
For each state in the SAM:

Number of new substrings contributed by that state is  
`len[state] âˆ’ len[link(state)]`

Here:
- `len[state]` is the longest substring represented by the state  
- `len[link(state)]` is the longest substring of its suffix-link parent  

Sum this value for all states to get the total number of distinct substrings.

3. Why this works  
Suffix automaton ensures:
- Every distinct substring corresponds to exactly one state  
- Difference of lengths counts how many new substrings appear at that state

4. Time Complexity  
Building SAM: O(n)  
Counting substrings: O(n)

SOLUTION:
#include <bits/stdc++.h>
using namespace std;

struct State {
    int len, link;
    map<char, int> next;
};

class Solution {
public:
    vector<State> st;
    int last;

    Solution() {
        st.reserve(200005);
    }

    void sa_init() {
        st.clear();
        st.push_back({0, -1, {}});
        last = 0;
    }

    void sa_extend(char c) {
        int cur = st.size();
        st.push_back({st[last].len + 1, 0, {}});
        
        int p = last;
        while (p != -1 && !st[p].next.count(c)) {
            st[p].next[c] = cur;
            p = st[p].link;
        }

        if (p == -1) {
            st[cur].link = 0;
        } else {
            int q = st[p].next[c];
            if (st[p].len + 1 == st[q].len) {
                st[cur].link = q;
            } else {
                int clone = st.size();
                st.push_back(st[q]);
                st[clone].len = st[p].len + 1;

                while (p != -1 && st[p].next[c] == q) {
                    st[p].next[c] = clone;
                    p = st[p].link;
                }

                st[q].link = st[cur].link = clone;
            }
        }

        last = cur;
    }

    long long countDistinctSubstrings(string &s) {
        sa_init();
        for (char c : s) sa_extend(c);

        long long result = 0;
        for (int i = 1; i < st.size(); i++) {
            result += st[i].len - st[st[i].link].len;
        }
        return result;
    }
};
