19 October 2025 | Path Sum in Binary Tree

Question:
Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
A leaf is a node with no children.

Approach:
We use a Depth-First Search (DFS) traversal with backtracking. Starting from the root node, we keep adding the node values to a running sum. When we reach a leaf node, we check if the accumulated sum equals the target value.
	1.	Base Case: If the node is NULL, we simply return.
	2.	Add Current Node: Include the node’s value in the ongoing sum.
	3.	Check Leaf Node: If it’s a leaf and the sum matches the target, we mark found = true.
	4.	Recursive Calls: Recur for both left and right subtrees.
	5.	Backtrack: Subtract the current node’s value before returning to explore other paths.

This approach ensures that we explore every root-to-leaf path and correctly identify if any of them meet the required sum condition.

SOLUTION:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
void pathsum(TreeNode* root , bool &found,int &sum,int target)
{
    if(!root || found)
    {
        return;
    }

    sum += root->val;
    if(sum == target && ((!root -> left)&& (!root->right)))
    {
        found = true;
        return;
    }
    pathsum(root->left,found,sum,target);
    pathsum(root->right,found,sum,target);
    sum -= root -> val;
}

class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root)
        {
            return false;
        }
        bool found = false;
        int sum = 0;
        pathsum(root,found,sum,targetSum);
        return found;
    }
};
