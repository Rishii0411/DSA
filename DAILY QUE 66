2025-11-06 | Count Paths With Sum Divisible by K in a Grid


Problem Statement  
Given an `m × n` integer matrix `grid` and an integer `k`, find the number of valid paths from `(0, 0)` to `(m−1, n−1)` where:

• You may move **only right or down**  
• The sum of numbers along the path is **divisible by k**
Return the count modulo `1000000007`.


Approach / Explanation  
1. Dynamic Programming with Remainders  
Use a 3D DP:  
`dp[i][j][r]` = number of ways to reach cell `(i, j)` such that the sum of numbers mod k equals `r`.
This works because:
- Modulo depends only on the current remainder
- DP transitions come from top or left
2. Transition  
Let `val = grid[i][j] % k`.  
To compute `dp[i][j][newR]`, we check both directions:
newR = (prevR + val) % k
dp[i][j][newR] += dp[i-1][j][prevR]  
dp[i][j][newR] += dp[i][j-1][prevR]
3. Base Case  
Starting cell:
dp[0][0][ grid[0][0] % k ] = 1
4. Final Answer  
Answer is `dp[m-1][n-1][0]`  
(sum divisible by k means remainder = 0)
5. Complexity  
Time: O(m * n * k)  
Space: O(m * n * k)


SOLUTION:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        const int MOD = 1e9 + 7;
        int m = grid.size(), n = grid[0].size();

        vector<vector<vector<long long>>> dp(
            m, vector<vector<long long>>(n, vector<long long>(k, 0))
        );

        dp[0][0][ grid[0][0] % k ] = 1;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int val = grid[i][j] % k;

                for (int r = 0; r < k; r++) {
                    int newR = (r + val) % k;

                    if (i > 0)
                        dp[i][j][newR] = (dp[i][j][newR] + dp[i-1][j][r]) % MOD;
                    if (j > 0)
                        dp[i][j][newR] = (dp[i][j][newR] + dp[i][j-1][r]) % MOD;
                }
            }
        }

        return dp[m-1][n-1][0];
    }
};
