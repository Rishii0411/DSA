2026-02-21 | Compute Researcher’s H-Index

	Question
Given citations[],
return the H-index of the researcher.

	Approach 1 (Sorting Based – Simple & Efficient)
1.	Sort the citations array in descending order.
2.	Traverse the array:
		At position i (0-based),
		check if citations[i] ≥ i + 1.
3.	The largest such i + 1 is the H-index.
4.	Time Complexity:
		O(n log n)
5.	Space Complexity:
		O(1)

	Solution (Sorting Method)

class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(), citations.end(), greater<int>());
        
        int h = 0;
        for (int i = 0; i < citations.size(); i++) {
            if (citations[i] >= i + 1)
                h = i + 1;
            else
                break;
        }
        
        return h;
    }
};

	Approach 2 (Fully Optimized – Counting / Bucket Method O(n))
1.	H-index cannot exceed n (number of papers).
2.	Create a bucket array of size n+1.
3.	For each citation:
		If citation ≥ n → increment bucket[n]
		Else → increment bucket[citation]
4.	Traverse from n down to 0,
		Keep cumulative count of papers.
		First index where cumulative ≥ index → answer.

	Solution (Optimal O(n))

class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        vector<int> bucket(n + 1, 0);

        for (int c : citations) {
            if (c >= n)
                bucket[n]++;
            else
                bucket[c]++;
        }

        int count = 0;
        for (int i = n; i >= 0; i--) {
            count += bucket[i];
            if (count >= i)
                return i;
        }

        return 0;
    }
};

	Key Insight
The H-index is bounded by n.
Using counting instead of sorting reduces the complexity
from O(n log n) to O(n).
