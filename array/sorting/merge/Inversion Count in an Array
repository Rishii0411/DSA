2026-02-18 | Inversion Count in an Array

	Question
Given arr[],
return the total number of inversions in the array.

	Approach
1.	Brute Force:
	-	Check all pairs.
	-	Time Complexity: O(n²) → too slow.
2.	Optimized Approach:
	-	Use **Merge Sort**.
3.	Key Idea:
	-	During merge step:
		If left[i] > right[j],
		then all remaining elements in left
		also form inversions with right[j].
4.	While merging:
		inversions += (mid − i + 1)
5.	This gives:
	-	Time Complexity: O(n log n)
	-	Space Complexity: O(n)

	Solution

class Solution {
public:
    long long mergeAndCount(vector<int>& arr, int left, int mid, int right) {
        vector<int> temp(right - left + 1);

        int i = left;
        int j = mid + 1;
        int k = 0;
        long long invCount = 0;

        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
                invCount += (mid - i + 1);
            }
        }

        while (i <= mid)
            temp[k++] = arr[i++];

        while (j <= right)
            temp[k++] = arr[j++];

        for (int p = 0; p < temp.size(); p++)
            arr[left + p] = temp[p];

        return invCount;
    }

    long long mergeSort(vector<int>& arr, int left, int right) {
        long long invCount = 0;

        if (left < right) {
            int mid = left + (right - left) / 2;

            invCount += mergeSort(arr, left, mid);
            invCount += mergeSort(arr, mid + 1, right);
            invCount += mergeAndCount(arr, left, mid, right);
        }

        return invCount;
    }

    long long inversionCount(vector<int>& arr) {
        return mergeSort(arr, 0, arr.size() - 1);
    }
};

	Key Insight
Merge sort naturally compares elements across halves.
Whenever a right element is placed before left elements,
all remaining left elements form inversions.
This reduces complexity from O(n²) to O(n log n).
