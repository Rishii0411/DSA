2025-12-12 | Minimum People Required to Cover the Working Day

	Question
Given an array arr[] representing coverage ranges of people,  
find the minimum number of people needed to cover the entire working day [0, n − 1], or return -1 if impossible.

	Approach
1.	Convert each available person into an interval:
	-	start = max(0, i − arr[i])
	-	end   = min(n − 1, i + arr[i])
2.	Ignore all arr[i] = -1 entries.
3.	Sort all intervals by:
	-	start ascending,
	-	if start is same, end descending.
4.	Use a **greedy interval covering strategy**:
	-	Start covering from position = 0.
	-	Among all intervals that start ≤ current position,
		select the one with the **farthest end**.
	-	Move current position to (farthest end + 1).
	-	Increment count.
5.	If at any point no interval can extend coverage:
	-	Return -1.
6.	Stop when current position > n − 1.
7.	This greedy strategy is optimal for minimum interval coverage.
8.	Time Complexity:
	-	O(n log n) due to sorting.
   Space Complexity:
	-	O(n)

	Solution

class Solution {
public:
    int minPeople(vector<int>& arr) {
        int n = arr.size();
        vector<pair<int,int>> intervals;

        // Build intervals
        for (int i = 0; i < n; i++) {
            if (arr[i] != -1) {
                int start = max(0, i - arr[i]);
                int end   = min(n - 1, i + arr[i]);
                intervals.push_back({start, end});
            }
        }

        // Sort intervals
        sort(intervals.begin(), intervals.end());

        int count = 0;
        int idx = 0;
        int curr = 0;

        // Greedy coverage
        while (curr < n) {
            int farthest = curr;

            while (idx < intervals.size() && intervals[idx].first <= curr) {
                farthest = max(farthest, intervals[idx].second + 1);
                idx++;
            }

            if (farthest == curr)
                return -1;

            count++;
            curr = farthest;
        }

        return count;
    }
};
