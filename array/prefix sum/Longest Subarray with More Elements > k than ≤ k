2026-02-25 | Longest Subarray with More Elements > k than ≤ k

	Question
Given arr[] and k,
return the length of the longest subarray
where elements greater than k are more
than elements less than or equal to k.

	Approach
1.	Key Transformation:
	Convert the problem into prefix sums.
2.	Map each element:
		If arr[i] > k → +1
		Else → -1
3.	Now the problem becomes:
		Find the longest subarray with sum > 0.
4.	Let prefix[i] = running sum.
5.	We need:
		prefix[j] - prefix[i-1] > 0
		⇒ prefix[j] > prefix[i-1]
6.	Use a hashmap to store
		the earliest index of each prefix value.
7.	Algorithm:
	1.	Initialize prefix = 0.
	2.	If prefix > 0 at index i,
			maxLen = i + 1.
	3.	If prefix - 1 exists in map,
			update maxLen.
	4.	Store earliest occurrence of prefix.
8.	Time Complexity:
		O(n)
9.	Space Complexity:
		O(n)

	Solution

class Solution {
public:
    int longestSubarray(vector<int>& arr, int k) {
        unordered_map<int, int> firstIndex;
        int prefix = 0;
        int maxLen = 0;

        for (int i = 0; i < arr.size(); i++) {
            if (arr[i] > k)
                prefix += 1;
            else
                prefix -= 1;

            if (prefix > 0)
                maxLen = i + 1;

            if (firstIndex.count(prefix - 1))
                maxLen = max(maxLen, i - firstIndex[prefix - 1]);

            if (!firstIndex.count(prefix))
                firstIndex[prefix] = i;
        }

        return maxLen;
    }
};

	Key Insight
By converting values to +1 and −1,
the condition becomes finding the longest subarray
with positive sum.
Prefix sums and a hashmap reduce the problem
to an efficient O(n) solution.
