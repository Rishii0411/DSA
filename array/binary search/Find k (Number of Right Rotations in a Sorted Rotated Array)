2026-02-09|Find k (Number of Right Rotations in a Sorted Rotated Array)

	Question
Given a right-rotated sorted array arr[] of distinct integers,  
find the number of right rotations k.

	Approach
1.	Key observation:
	-	After rotation, the **minimum element** in the array indicates the pivot.
	-	The index of the minimum element tells how many **left rotations** happened.
2.	For a sorted array:
	-	Left rotations = index of the minimum element.
3.	But we need **right rotations**:
			rightRotations = n − leftRotations
4.	So:
			k = (n − indexOfMin) % n
5.	Since the array is sorted and rotated:
	-	The minimum element can be found efficiently using **binary search**.
6.	Time Complexity: O(log n)  
   Space Complexity: O(1)

	Solution

class Solution {
public:
    int findRotationCount(vector<int>& arr) {
        int n = arr.size();
        int low = 0, high = n - 1;

        while (low <= high) {
            // If array is already sorted
            if (arr[low] <= arr[high])
                return (n - low) % n;

            int mid = low + (high - low) / 2;
            int next = (mid + 1) % n;
            int prev = (mid - 1 + n) % n;

            // Check if mid is minimum
            if (arr[mid] <= arr[next] && arr[mid] <= arr[prev]) {
                return (n - mid) % n;
            }

            // Decide which half to search
            if (arr[mid] >= arr[low])
                low = mid + 1;
            else
                high = mid - 1;
        }

        return 0;
    }
};

	Key Insight
The number of right rotations is directly linked to the
position of the smallest element. Finding that pivot
using binary search gives an optimal O(log n) solution.
