2025-12-12 | Maximum Square Side Length with Sum ≤ Threshold

	Question
Given a matrix mat and an integer threshold,  
return the maximum side length of a square whose sum is less than or equal to threshold, or 0 if none exists.

	Approach
1.	Use a **2D prefix sum** to compute submatrix sums in O(1).
2.	Build prefixSum where:
		prefix[i][j] = sum of elements in rectangle (0,0) to (i−1,j−1)
3.	The sum of a k × k square with top-left at (i, j) is:
		sum = prefix[i+k][j+k]
		      − prefix[i][j+k]
		      − prefix[i+k][j]
		      + prefix[i][j]
4.	The answer (maximum k) is **monotonic**:
	-	If a square of size k exists with sum ≤ threshold,
	  then all sizes < k also exist.
5.	Therefore, apply **binary search on k** from 1 to min(m, n).
6.	For each candidate k:
	-	Check all possible k × k squares using prefix sums.
	-	If any square satisfies the condition, k is feasible.
7.	Return the largest feasible k.
8.	Time Complexity:
	-	Prefix sum: O(mn)
	-	Binary search checks: O(mn log(min(m,n)))
9.	Space Complexity:
	-	O(mn)

	Solution

class Solution {
public:
    int maxSideLength(vector<vector<int>>& mat, int threshold) {
        int m = mat.size();
        int n = mat[0].size();

        // Build prefix sum
        vector<vector<int>> pref(m + 1, vector<int>(n + 1, 0));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                pref[i + 1][j + 1] =
                    pref[i][j + 1] +
                    pref[i + 1][j] -
                    pref[i][j] +
                    mat[i][j];
            }
        }

        auto can = [&](int k) {
            for (int i = 0; i + k <= m; i++) {
                for (int j = 0; j + k <= n; j++) {
                    int sum =
                        pref[i + k][j + k] -
                        pref[i][j + k] -
                        pref[i + k][j] +
                        pref[i][j];
                    if (sum <= threshold)
                        return true;
                }
            }
            return false;
        };

        int low = 1, high = min(m, n), ans = 0;

        while (low <= high) {
            int mid = (low + high) / 2;
            if (can(mid)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return ans;
    }
};
