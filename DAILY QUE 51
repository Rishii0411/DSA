2025-11-06 | Minimum Operations to Make Array Elements Equal to 1

Find the minimum number of operations required to achieve this —
or determine if it’s impossible to reach that state. ⚙️

Problem Statement
You are given a 0-indexed array nums[] consisting of positive integers.
You can perform the following operation any number of times:
	•	Choose an index i such that 0 ≤ i < n - 1, and
replace either nums[i] or nums[i + 1] with gcd(nums[i], nums[i + 1]).

Return the minimum number of operations needed to make all elements of nums equal to 1,
or -1 if it’s impossible.

Key Observations

1. Base Case — GCD of Entire Array
If the GCD of the entire array is greater than 1,
then it’s impossible to make all elements 1.
Why?
Because GCD can only decrease or stay the same, never increase.

Thus, if gcd(nums[0], nums[1], …, nums[n-1]) != 1, return -1.

2. If There Is Already a 1
If any element in the array is 1,
you can make all others 1 using it as a “spreader” in (n - count_of_ones) operations.

Example:

nums = [2, 1, 3]
→ Already contains 1 → takes (3 - 1) = 2 operations.

3. If No 1 Exists
We need to create the first 1 by combining adjacent pairs.

How?
Find the shortest subarray whose GCD is 1.
If the shortest subarray with GCD 1 has length L,
then it will take (L - 1) operations to create a 1 from it.

Once a single 1 exists,
you can make all other elements 1 in (n - 1) more operations.

Total = (L - 1) + (n - 1) = n + L - 2

Step-by-Step Algorithm
	1.	Compute the GCD of all elements.
	•	If it’s > 1, return -1.
	2.	Check if any element is already 1.
	•	If yes, answer = n - count(1s).
	3.	Otherwise, find the shortest subarray with GCD = 1:
	•	For each starting index i, compute GCDs incrementally until you find 1.
	•	Track the minimum length L.
	4.	Return n + L - 2.

Complexity Analysis

Step	Complexity
GCD of entire array	O(n)
Finding shortest subarray GCD = 1	O(n²) worst case
Total Time	O(n²)
Space	O(1)

SOLUTION:

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();

        // Step 1: Check if GCD of all numbers > 1 (impossible case)
        int g = nums[0];
        for (int x : nums)
            g = gcd(g, x);
        if (g > 1)
            return -1;

        // Step 2: If there's already a '1' in the array
        int count_ones = count(nums.begin(), nums.end(), 1);
        if (count_ones > 0)
            return n - count_ones;

        // Step 3: Find shortest subarray with GCD = 1
        int minLen = INT_MAX;
        for (int i = 0; i < n; i++) {
            int currGCD = nums[i];
            for (int j = i + 1; j < n; j++) {
                currGCD = gcd(currGCD, nums[j]);
                if (currGCD == 1) {
                    minLen = min(minLen, j - i + 1);
                    break;
                }
            }
        }

        // Step 4: If no subarray gives GCD 1 (shouldn't happen here)
        if (minLen == INT_MAX) return -1;

        // Total operations = (to make 1) + (spread it)
        return (minLen - 1) + (n - 1);
    }
};
