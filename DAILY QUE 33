2025-10-28 | Valid Selections in Array

Question
Given an integer array nums,
Return the count of (start_index, direction) pairs that result in all elements of nums becoming 0 when the described process is applied.

Approach
	1.	Try every zero index — since the start must be where nums[i] == 0.
	2.	Try both directions — left (-1) and right (+1).
	3.	Simulate the described process:
	•	Use a copy of the array (so you don’t mutate the original for the next trial).
	•	Move according to rules:
	•	If you go out of bounds → stop.
	•	If current cell is 0 → move same direction.
	•	If >0 → decrement, reverse direction, move one step.
	4.	After process ends, check if all elements became 0.
	5.	Count all pairs (start, direction) that meet the condition.

Directions can be represented as:
	•	+1 → move right
	•	-1 → move left

SOLUTION:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int validSelections(vector<int>& nums) {
        int n = nums.size();
        int validCount = 0;

        for (int start = 0; start < n; start++) {
            if (nums[start] != 0) continue; // must start at zero

            // Try both directions: left (-1) and right (+1)
            for (int dir : {-1, 1}) {
                vector<int> arr = nums;  // make a copy
                int curr = start;
                int d = dir;

                while (curr >= 0 && curr < n) {
                    if (arr[curr] == 0) {
                        curr += d;
                    } else {
                        arr[curr]--;
                        d = -d;       // reverse direction
                        curr += d;
                    }
                }

                // Check if all became zero
                if (all_of(arr.begin(), arr.end(), [](int x){ return x == 0; }))
                    validCount++;
            }
        }
        return validCount;
    }
};

int main() {
    Solution s;
    vector<int> nums = {0, 1, 0, 1};
    cout << s.validSelections(nums) << endl;
    return 0;
}
