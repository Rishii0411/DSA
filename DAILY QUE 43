2025-11-06 | Find the Floor of an Element in a Sorted Array

Problem Statement
Given a sorted array arr[] of size n and an integer x, find the index (0-based) of the largest element that is less than or equal to x.
If such an element doesn’t exist, return -1.

Note:
If multiple occurrences of the floor element exist, return the index of the last occurrence.

Approach / Explanation
	1.	Observation
• Because the array is sorted, we can efficiently use Binary Search.
• During the search, we’ll track the best candidate that is ≤ x.
	2.	Binary Search Logic
• Initialize low = 0, high = n - 1, and ans = -1.
• While low <= high:
	•	Compute mid = (low + high) / 2.
	•	If arr[mid] <= x, then:
	•	This could be a potential floor → update ans = mid.
	•	But maybe there’s a larger valid element → move right (low = mid + 1).
	•	Else (arr[mid] > x):
	•	Move left (high = mid - 1).
• Return ans.
	3.	Time and Space Complexity
• Time Complexity: O(log n)
• Space Complexity: O(1)

SOLUTION:

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int findFloor(vector<int>& arr, int x) {
        int low = 0, high = arr.size() - 1;
        int ans = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] <= x) {
                ans = mid;        // possible floor found
                low = mid + 1;    // move right to find last occurrence
            } else {
                high = mid - 1;   // move left
            }
        }

        return ans;
    }
};
