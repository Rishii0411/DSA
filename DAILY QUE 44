2025-11-06 | Power Grid Maintenance Queries

Problem Statement
You are given:
	•	c (number of stations, 1-based indexing).
	•	connections, a 2D array of bidirectional connections between stations.
	•	queries, a list of operations as described.

Return an array containing the result of each [1, x] query.

Approach / Explanation

1. Observation
	•	The power grid structure never changes, so connected components (grids) are static.
	•	The only dynamic property is which stations are online/offline.
	•	For each grid, we can efficiently track:
	•	Which stations belong to it.
	•	The smallest online station in that grid.

2. Steps
Step 1: Build the Power Grids
	•	Use Union-Find (Disjoint Set Union - DSU) to group stations that are connected (directly or indirectly).
	•	After processing all connections, each station belongs to a component represented by a root node.

Step 2: Organize Stations per Grid
	•	For each component (grid), store all its stations in a sorted set (like std::set<int>).
	•	This allows quick access to the smallest online station.

Step 3: Handle Queries
	•	Maintain an online array to track which stations are active.
	•	For query [1, x]:
	•	If x is online → return x.
	•	Otherwise, find x’s root (grid), and return the smallest online station in that grid (or -1 if none).
	•	For query [2, x]:
	•	Mark x offline and remove it from its grid’s set.

3. Time Complexity
	•	DSU operations: O(α(n)) ≈ O(1)
	•	Query processing:
	•	Each [1, x]: O(1) or O(log n) (to fetch min).
	•	Each [2, x]: O(log n) (for deletion).
	•	Total: O((n + q) log n)


SOLUTION:

#include <bits/stdc++.h>
using namespace std;

class DSU {
public:
    vector<int> parent, size;
    DSU(int n) {
        parent.resize(n + 1);
        size.resize(n + 1, 1);
        for (int i = 1; i <= n; i++) parent[i] = i;
    }

    int find(int x) {
        if (x == parent[x]) return x;
        return parent[x] = find(parent[x]);
    }

    void unite(int a, int b) {
        a = find(a);
        b = find(b);
        if (a == b) return;
        if (size[a] < size[b]) swap(a, b);
        parent[b] = a;
        size[a] += size[b];
    }
};

class Solution {
public:
    vector<int> powerGridQueries(int c, vector<vector<int>>& connections, vector<vector<int>>& queries) {
        DSU dsu(c);

        // Step 1: Build grids using DSU
        for (auto &e : connections) {
            dsu.unite(e[0], e[1]);
        }

        // Step 2: Group stations by grid
        unordered_map<int, set<int>> gridOnline;
        for (int i = 1; i <= c; i++) {
            int root = dsu.find(i);
            gridOnline[root].insert(i); // all stations initially online
        }

        vector<int> online(c + 1, 1);
        vector<int> result;

        // Step 3: Process queries
        for (auto &q : queries) {
            int type = q[0], x = q[1];
            int root = dsu.find(x);

            if (type == 1) {  // maintenance check
                if (online[x]) {
                    result.push_back(x);
                } else {
                    if (!gridOnline[root].empty())
                        result.push_back(*gridOnline[root].begin()); // smallest online ID
                    else
                        result.push_back(-1);
                }
            } 
            else if (type == 2) {  // go offline
                if (online[x]) {
                    online[x] = 0;
                    gridOnline[root].erase(x);
                }
            }
        }

        return result;
    }
};
