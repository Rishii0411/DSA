2025-09-23 | Maximum of Minimum for Every Window Size

Question

You are given an integer array arr[], the task is to find the maximum of minimum values for every window size k where 1 ≤ k ≤ arr.size().
	•	For each window size k:
	•	Consider all contiguous subarrays of length k.
	•	Find the minimum element in each subarray.
	•	Take the maximum among all these minimums.

Return the results as an array, where the element at index i represents the answer for window size i+1.

Approach
	1.	Observation
	•	Each element in the array can be the minimum of some window size.
	•	The task is to determine the largest window size in which an element is the minimum.
	2.	Next Smaller Element (Right) & Previous Smaller Element (Left)
	•	For each element arr[i], find:
	•	Left boundary: index of the previous smaller element.
	•	Right boundary: index of the next smaller element.
	•	From these, compute the window size in which arr[i] is the minimum:
	3.	Store Best Values
	•	For each windowSize, keep track of the maximum value among all possible elements that can be the minimum of that window.
	4.	Propagate Results
	•	Fill the result array from size 1 to n.
	•	Since smaller windows can use values from larger windows, propagate maximums backward.

SOLUTION:
class Solution {
public:
    vector<int> maxOfMins(vector<int>& arr) {
        int n = arr.size();
        vector<int> result(n), best(n + 1, 0);
        stack<int> st;

        // --- Step 1: Find window size for each element ---
        for (int i = 0; i < n; i++) {
            while (!st.empty() && arr[st.top()] >= arr[i]) {
                int idx = st.top();
                st.pop();

                int left = st.empty() ? -1 : st.top();
                int right = i;
                int windowSize = right - left - 1;

                best[windowSize] = max(best[windowSize], arr[idx]);
            }
            st.push(i);
        }

        // --- Step 2: Process remaining elements ---
        while (!st.empty()) {
            int idx = st.top();
            st.pop();

            int left = st.empty() ? -1 : st.top();
            int right = n;
            int windowSize = right - left - 1;

            best[windowSize] = max(best[windowSize], arr[idx]);
        }

        // --- Step 3: Fill result array ---
        for (int size = 1; size <= n; size++) {
            result[size - 1] = best[size];
        }

        // --- Step 4: Propagate maximums backwards ---
        for (int i = n - 2; i >= 0; i--) {
            result[i] = max(result[i], result[i + 1]);
        }

        return result;
    }
};
