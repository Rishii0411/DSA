October 21, 2025 | Symmetric Tree

Question:
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).Approach:
	1.	The problem is solved using recursion.
	2.	A helper function ismirror() is used to compare the left and right subtrees.
	3.	The base cases handle three conditions:
	•	If both subtrees are NULL, they are symmetric.
	•	If one subtree is NULL and the other is not, they are not symmetric.
	4.	Otherwise, we recursively compare:
	•	The left child of the left subtree with the right child of the right subtree.
	•	The right child of the left subtree with the left child of the right subtree.
	5.	The main function isSymmetric() initiates this process by checking if the left and right subtrees of the root are mirrors.

This approach efficiently ensures that both the structure and values match in a mirrored fashion.

SOLUTION:
#include <bits/stdc++.h>
using namespace std;

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    bool ismirror(TreeNode* leftsub, TreeNode* rightsub) {
        if (!leftsub && !rightsub) {
            return true;
        } 
        else if (!leftsub || !rightsub) {
            return false;
        }

        return (leftsub->val == rightsub->val) &&
               ismirror(leftsub->left, rightsub->right) &&
               ismirror(leftsub->right, rightsub->left);
    }

    bool isSymmetric(TreeNode* root) {
        if (!root) {
            return true;
        }
        return ismirror(root->left, root->right);
    }
};
