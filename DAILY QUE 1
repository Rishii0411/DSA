2025-09-24 | Minimum Jumps to Reach End of Array

Question

You are given an array arr[] of non-negative integers. Each number indicates the maximum number of steps you can jump forward from that position:
	•	If arr[i] = 3, you can jump to i + 1, i + 2, or i + 3.
	•	If arr[i] = 0, you cannot jump forward from this position.

Determine the minimum number of jumps required to reach the last index from the first index.
	•	Return -1 if it is not possible to reach the end.

Approach
	1.	Initialization
	•	maxReach → The farthest index reachable so far.
	•	steps → Number of steps we can still take in the current jump.
	•	jumps → Count of jumps made.
	2.	Iterate through the array
	•	For each index i:
	•	Update maxReach as max(maxReach, i + arr[i]).
	•	Decrement steps (we’ve used a step to move forward).
	3.	Make a jump if steps reach 0
	•	Increment jumps.
	•	Reset steps to maxReach - i (steps available in the next jump).
	•	If i >= maxReach at any point, return -1 (stuck).
	4.	End Condition
	•	If we reach the last index, return jumps.

This approach is greedy, always trying to move as far as possible in the current jump to minimize total jumps.

SOLUTION:
class Solution {
public:
    int minJumps(vector<int>& arr) {
        int n = arr.size();
        if (n <= 1) return 0;       // Already at the end
        if (arr[0] == 0) return -1; // Can't move anywhere

        int maxReach = arr[0];   // Farthest index reachable
        int steps = arr[0];      // Steps we can still take
        int jumps = 1;           // At least one jump needed

        for (int i = 1; i < n; i++) {
            // Reached the end
            if (i == n - 1) return jumps;

            maxReach = max(maxReach, i + arr[i]);
            steps--;

            // If no steps left, we must jump
            if (steps == 0) {
                jumps++;

                // If current index >= maxReach, stuck
                if (i >= maxReach) return -1;

                steps = maxReach - i; // Reset steps
            }
        }
        return -1;
    }
};
