
2025-10-04 | Geek’s Training Program – Max Merit Points

Problem Statement

Given a 2D array arr[n][3] where:
	•	arr[i][0] = points for Running on day i
	•	arr[i][1] = points for Fighting on day i
	•	arr[i][2] = points for Learning Practice on day i

Find the maximum merit points Geek can achieve in n days, such that he doesn’t repeat the same activity on two consecutive days.

Approach / Explanation
	1.	Dynamic Programming State
	•	Let dp[i][j] represent the maximum points achievable up to day i, if Geek chooses activity j on day i.
	•	We consider 3 activities but store them in a shifted DP table with indices 1, 2, 3 for convenience.
	2.	Base Case (Day 0)
	•	dp[0][1] = arr[0][0] (Running)
	•	dp[0][2] = arr[0][1] (Fighting)
	•	dp[0][3] = arr[0][2] (Learning)
	3.	Transition Relation
	•	If Geek chooses Running on day i → He must come from either Fighting or Learning on day i-1.  

SOLUTION:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maximumPoints(vector<vector<int>>& arr) {
        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(4, 0));

        // Base case: first day
        dp[0][1] = arr[0][0]; // Running
        dp[0][2] = arr[0][1]; // Fighting
        dp[0][3] = arr[0][2]; // Learning

        // Fill DP table
        for (int i = 1; i < n; i++) {
            dp[i][1] = max(dp[i-1][2], dp[i-1][3]) + arr[i][0];
            dp[i][2] = max(dp[i-1][1], dp[i-1][3]) + arr[i][1];
            dp[i][3] = max(dp[i-1][1], dp[i-1][2]) + arr[i][2];
        }

        // Answer is max of last row
        return max({dp[n-1][1], dp[n-1][2], dp[n-1][3]});
    }
};
