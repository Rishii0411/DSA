2025-11-06 | Smallest Subarray to Remove for Sum Divisible by p

Problem Statement  
Given positive integer array `nums` and an integer `p`, remove the smallest contiguous subarray such that the sum of the remaining array is divisible by p.
Return:
- the length of the smallest subarray to remove  
- or -1 if impossible.


Approach / Explanation  
1. Let total sum = S  
We need subarray sum ≡ S % p (mod p).

Let target = S % p  
If target == 0 → no need to remove anything → answer = 0.

2. Prefix Sum Technique  
We compute prefix sums:
prefix[i] = sum(nums[0..i-1]) % p
For subarray nums[l..r]:
subSum = prefix[r+1] − prefix[l] (mod p)

We want:

(prefix[r+1] − prefix[l]) % p == target  
→ prefix[l] == (prefix[r+1] − target + p) % p

3. Use Hash Map to store earliest index of each prefix remainder  
While scanning:

- Compute current prefix remainder cur
- Compute required previous remainder req  
  req = (cur − target + p) % p  

If req exists in the map, we found a valid subarray removal candidate:
len = i − map[req]

Take minimum len.

4. Constraints  
We must ensure the subarray removed is **not the entire array**.

5. Complexity  
Time: O(n)  
Space: O(p) or O(n)


SOLUTION:
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minSubarray(vector<int>& nums, int p) {
        long long total = 0;
        for (int x : nums) total += x;
        
        int target = total % p;
        if (target == 0) return 0;

        unordered_map<int, int> mp;
        mp[0] = -1;  // prefix before start

        long long prefix = 0;
        int ans = nums.size();

        for (int i = 0; i < nums.size(); i++) {
            prefix = (prefix + nums[i]) % p;
            int req = (prefix - target + p) % p;

            if (mp.count(req)) {
                ans = min(ans, i - mp[req]);
            }

            // store this prefix index
            mp[prefix] = i;
        }

        return (ans == nums.size() ? -1 : ans);
    }
};
